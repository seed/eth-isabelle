chapter \<open>Generated by Lem from \<open>lem/rlplem.lem\<close>.\<close>

theory "Rlplem" 

imports
  Main
  "LEM.Lem_pervasives"
  "LEM.Lem_word"
  "Word256"
  "Word160"
  "Word8"
  "Keccak"

begin 

(**)
(* Copyright 2016 Sami MÃ¤kelÃ¤ *)
(*  Licensed under the Apache License, Version 2.0 (the License); *)
(*  you may not use this file except in compliance with the License. *)
(*  You may obtain a copy of the License at *)
(**)
(*     http://www.apache.org/licenses/LICENSE-2.0 *)
(**)
(* Unless required by applicable law or agreed to in writing, software *)
(* distributed under the License is distributed on an AS IS BASIS, *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

(*open import Pervasives*)
(*open import Word*)
(*open import Word256*)
(*open import Word160*)
(*open import Word8*)
(*open import Keccak*)

type_synonym byte0 ="  8 word "

datatype tree =
   Leaf " byte0 list "
 | Node " tree list "

(*val BE_rev_prim : natural -> natural -> list byte*)
function (sequential,domintros)  BE_rev_prim  :: " nat \<Rightarrow> nat \<Rightarrow>( 8 word)list "  where 
     " BE_rev_prim 0 n = ( [])"
|" BE_rev_prim ((Suc limit)) n = ( 
   if n =( 0 :: nat) then [] else
   if n <( 256 :: nat) then [word8FromNatural n] else
         (word8FromNatural (n mod( 256 :: nat)) # BE_rev_prim limit (n div( 256 :: nat))))" 
by pat_completeness auto


(*val BE_rev : natural -> list byte*)
function (sequential,domintros)  BE_rev  :: " nat \<Rightarrow>( 8 word)list "  where 
     " BE_rev 0 = ( [])"
|" BE_rev n = ( if n <( 256 :: nat) then [word8FromNatural n] else
         (word8FromNatural (n mod( 256 :: nat)) # BE_rev (n div( 256 :: nat))))" 
by pat_completeness auto


(*val BE : natural -> list byte*)
definition BE  :: " nat \<Rightarrow>( 8 word)list "  where 
     " BE n = ( List.rev (BE_rev n))"


(*val BE_nat : nat -> list byte*)
definition BE_nat  :: " nat \<Rightarrow>( 8 word)list "  where 
     " BE_nat n = ( List.rev (BE_rev ( n)))"


(*val BD_rev : list byte -> natural*)
function (sequential,domintros)  BD_rev  :: "( 8 word)list \<Rightarrow> nat "  where 
     " BD_rev ([]) = (( 0 :: nat))"
|" BD_rev (h # t) = ((( 256 :: nat) * BD_rev t) + unat h )" 
by pat_completeness auto


(*val BD : list byte -> natural*)
definition BD  :: "( 8 word)list \<Rightarrow> nat "  where 
     " BD lst = ( BD_rev (List.rev lst))"


(*val r_b : list byte -> list byte*)
fun r_b  :: "( 8 word)list \<Rightarrow>( 8 word)list "  where 
     " r_b ([]) = ( [(((word_of_int 128) ::  8 word))])"
|" r_b ([k]) = ( if unat k <( 128 :: nat) then [k] else [(((word_of_int 129) ::  8 word)), k])"
|" r_b lst = (
   if List.length lst <( 56 :: nat) then word8FromNat (( 128 :: nat) + List.length lst) # lst
    else word8FromNat (( 183 :: nat) + List.length (BE_nat (List.length lst))) # (BE_nat (List.length lst) @ lst))"


(*val read_n_bytes : nat -> list byte -> maybe (list byte  * list byte)*)
definition read_n_bytes  :: " nat \<Rightarrow>( 8 word)list \<Rightarrow>(( 8 word)list*( 8 word)list)option "  where 
     " read_n_bytes n lst = (
  if List.length lst \<ge> n then Some (List.take n lst, List.drop n lst)
  else None )"


(*val de_r_b : list byte -> maybe (list byte * list byte)*)
fun de_r_b  :: "( 8 word)list \<Rightarrow>(( 8 word)list*( 8 word)list)option "  where 
     " de_r_b ([]) = ( None )"
|" de_r_b (k # lst) = (
   if k =(((word_of_int 128) ::  8 word)) then Some ([], lst)
   else if word_sless k(((word_of_int 128) ::  8 word)) then Some ([k], lst)
   else if word_sless k(((word_of_int 184) ::  8 word)) then
       ((let len = (unat k -( 128 :: nat)) in
       (if List.length lst \<ge> len then Some (List.take len lst, List.drop len lst)
                                         else None)))
   else if word_sle k(((word_of_int 192) ::  8 word)) then
      (case  read_n_bytes (unat k -( 183 :: nat)) lst of
         None => None
       | Some (be_bytes, x_and_rest) =>
         read_n_bytes ( (BD be_bytes)) x_and_rest
      )
   else None )"


(*val RLP : tree -> list byte*)
function (sequential,domintros)  RLP  :: " tree \<Rightarrow>(byte0)list "  where 
     " RLP (Leaf l) = ( r_b l )"
|" RLP (Node lst) = (
   (let s = (List.concat (List.map RLP lst)) in
   (let len_s = (List.length s) in
   if len_s <( 56 :: nat) then word8FromNat (( 192 :: nat) + len_s) # s
   else word8FromNat (( 247 :: nat) + List.length (BE_nat len_s)) # (BE_nat len_s @ s))))" 
by pat_completeness auto
   

(*val RLP_nat : natural -> list byte*)
definition RLP_nat  :: " nat \<Rightarrow>(byte0)list "  where 
     " RLP_nat i = ( RLP (Leaf (BE i)))"


(*val RLP_w256 : word256 -> tree*)
definition RLP_w256  :: " 256 word \<Rightarrow> tree "  where 
     " RLP_w256 i = ( Leaf (BE (nat (abs (uint i)))))"


(*val word_rsplit160 : word160 -> list byte*)
(*let word_rsplit160 w=  (word_rsplit_aux (boolListFromWord160 w) 20)*)

(*
val RLP_address : word160 -> tree
let RLP_address i = Leaf (BE (naturalFromInteger (word160ToInteger i)))
*)

(*val RLP_address : word160 -> tree*)
definition RLP_address  :: " 160 word \<Rightarrow> tree "  where 
     " RLP_address addr = ( Leaf (word_rsplit addr))"


end
